<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Nested datatype | Elasticsearch Reference [master] | Elastic</title>
<link rel="home" href="index.html" title="Elasticsearch Reference [master]"/>
<link rel="up" href="mapping-types.html" title="Field datatypes"/>
<link rel="prev" href="keyword.html" title="Keyword datatype"/>
<link rel="next" href="number.html" title="Numeric datatypes"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/master"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="master"/>
</head>
<body><div class="page_header">
You are looking at preliminary documentation for a future release.
Not what you want? See the
<a href="../current/index.html">current release documentation</a>.
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch Reference [master]</a></span>
»
<span class="breadcrumb-link"><a href="mapping.html">Mapping</a></span>
»
<span class="breadcrumb-link"><a href="mapping-types.html">Field datatypes</a></span>
»
<span class="breadcrumb-node">Nested datatype</span>
</div>
<div class="navheader">
<span class="prev">
<a href="keyword.html">« Keyword datatype</a>
</span>
<span class="next">
<a href="number.html">Numeric datatypes »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="nested"></a>Nested datatype<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/mapping/types/nested.asciidoc">edit</a></h2>
</div></div></div>

<p>The <code class="literal">nested</code> type is a specialised version of the <a class="xref" href="object.html" title="Object datatype"><code class="literal">object</code></a> datatype
that allows arrays of objects to be indexed in a way that they can be queried
independently of each other.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>When ingesting key-value pairs with a large, arbitrary set of keys, you might consider modeling each key-value pair as its own nested document with <code class="literal">key</code> and <code class="literal">value</code> fields. Instead, consider using the <a class="xref" href="flattened.html" title="Flattened datatype">flattened</a> datatype, which maps an entire object as a single field and allows for simple searches over its contents.
Nested documents and queries are typically expensive, so using the <code class="literal">flattened</code> datatype for this use case is a better option.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="nested-arrays-flattening-objects"></a>How arrays of objects are flattened<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/mapping/types/nested.asciidoc">edit</a></h3>
</div></div></div>
<p>Elasticsearch has no concept of inner objects. Therefore, it flattens object
hierarchies into a simple list of field names and values. For instance, consider the
following document:</p>
<div class="pre_wrapper lang-csharp alternative">
<pre class="programlisting prettyprint lang-csharp alternative">var indexResponse = client.Index(new GroupDoc
{
    Group = "fans",
    User = new List&lt;User&gt;
                    {
                        new User { First = "John", Last = "Smith" },
                        new User { First = "Alice", Last = "White" }
                    }
}, i =&gt; i
.Index("my_index")
.Id(1)
);</pre>
</div>
<div class="pre_wrapper lang-python alternative">
<pre class="programlisting prettyprint lang-python alternative">resp = client.index(
    index="my_index",
    id="1",
    body={
        "group": "fans",
        "user": [
            {"first": "John", "last": "Smith"},
            {"first": "Alice", "last": "White"},
        ],
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.index(
  index: 'my_index',
  id: 1,
  body: {
    group: 'fans',
    user: [
      {
        first: 'John',
        last: 'Smith'
      },
      {
        first: 'Alice',
        last: 'White'
      }
    ]
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Index(
	"my_index",
	strings.NewReader(`{
	  "group": "fans",
	  "user": [
	    {
	      "first": "John",
	      "last": "Smith"
	    },
	    {
	      "first": "Alice",
	      "last": "White"
	    }
	  ]
	}`),
	es.Index.WithDocumentID("1"),
	es.Index.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<pre class="programlisting prettyprint lang-js alternative">const response = await client.index({
  index: 'my_index',
  id: '1',
  body: {
    group: 'fans',
    user: [
      {
        first: 'John',
        last: 'Smith'
      },
      {
        first: 'Alice',
        last: 'White'
      }
    ]
  }
})
console.log(response)</pre>
</div>
<a id="8baccd8688a6bad1749b8935f9601ea4"></a>
<div class="pre_wrapper lang-console default has-csharp has-python has-ruby has-go has-js">
<pre class="programlisting prettyprint lang-console default has-csharp has-python has-ruby has-go has-js">PUT my_index/_doc/1
{
  "group" : "fans",
  "user" : [ <a id="CO305-1"></a><i class="conum" data-value="1"></i>
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}</pre>
</div>
<div class="console_widget has-csharp has-python has-ruby has-go has-js" data-snippet="snippets/653.console"></div>
<div class="calloutlist default has-csharp has-python has-ruby has-go has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO305-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">user</code> field is dynamically added as a field of type <code class="literal">object</code>.</p>
</td>
</tr>
</table>
</div>
<p>The previous document would be transformed internally into a document that looks more like this:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "group" :        "fans",
  "user.first" : [ "alice", "john" ],
  "user.last" :  [ "smith", "white" ]
}</pre>
</div>
<p>The <code class="literal">user.first</code> and <code class="literal">user.last</code> fields are flattened into multi-value fields,
and the association between <code class="literal">alice</code> and <code class="literal">white</code> is lost.  This document would
incorrectly match a query for <code class="literal">alice AND smith</code>:</p>
<div class="pre_wrapper lang-csharp alternative">
<pre class="programlisting prettyprint lang-csharp alternative">var searchResponse = client.Search&lt;GroupDoc&gt;(s =&gt; s
    .Index("my_index")
    .Query(q =&gt; q
        .Match(m =&gt; m
            .Field(f =&gt; f.User[0].First) <a id="A683-CO1-1"></a><i class="conum" data-value="1"></i>
            .Query("Alice")
        ) &amp;&amp; q
        .Match(m =&gt; m
            .Field(f =&gt; f.User[0].Last) <a id="A683-CO1-2"></a><i class="conum" data-value="2"></i>
            .Query("Smith")
        )
    )
);</pre>
</div>
<div class="pre_wrapper lang-python alternative">
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    index="my_index",
    body={
        "query": {
            "bool": {
                "must": [
                    {"match": {"user.first": "Alice"}},
                    {"match": {"user.last": "Smith"}},
                ]
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'my_index',
  body: {
    query: {
      bool: {
        must: [
          {
            match: {
              "user.first": 'Alice'
            }
          },
          {
            match: {
              "user.last": 'Smith'
            }
          }
        ]
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithIndex("my_index"),
	es.Search.WithBody(strings.NewReader(`{
	  "query": {
	    "bool": {
	      "must": [
	        {
	          "match": {
	            "user.first": "Alice"
	          }
	        },
	        {
	          "match": {
	            "user.last": "Smith"
	          }
	        }
	      ]
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  index: 'my_index',
  body: {
    query: {
      bool: {
        must: [
          {
            match: {
              'user.first': 'Alice'
            }
          },
          {
            match: {
              'user.last': 'Smith'
            }
          }
        ]
      }
    }
  }
})
console.log(response)</pre>
</div>
<a id="b214942b938e47f2c486e523546cb574"></a>
<div class="pre_wrapper lang-console default has-csharp has-python has-ruby has-go has-js">
<pre class="programlisting prettyprint lang-console default has-csharp has-python has-ruby has-go has-js">GET my_index/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "user.first": "Alice" }},
        { "match": { "user.last":  "Smith" }}
      ]
    }
  }
}</pre>
</div>
<div class="console_widget has-csharp has-python has-ruby has-go has-js" data-snippet="snippets/654.console"></div>
<div class="calloutlist alternative lang-csharp">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#A683-CO1-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>An expression to build a path to the field <code class="literal">user.first</code> from the <code class="literal">GroupDoc</code> type.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#A683-CO1-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>An expression to build a path to the field <code class="literal">user.last</code> from the <code class="literal">GroupDoc</code> type.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="nested-fields-array-objects"></a>Using <code class="literal">nested</code> fields for arrays of objects<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/mapping/types/nested.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to index arrays of objects and to maintain the independence of
each object in the array, use the <code class="literal">nested</code> datatype instead of the
<a class="xref" href="object.html" title="Object datatype"><code class="literal">object</code></a> datatype.</p>
<p>Internally, nested objects index each object in
the array as a separate hidden document, meaning that each nested object can be
queried independently of the others with the <a class="xref" href="query-dsl-nested-query.html" title="Nested query"><code class="literal">nested</code> query</a>:</p>
<div class="pre_wrapper lang-csharp alternative">
<pre class="programlisting prettyprint lang-csharp alternative">var createIndexResponse = client.Indices.Create("my_index", c =&gt; c
    .Map&lt;GroupDoc&gt;(m =&gt; m
        .Properties(p =&gt; p
            .Nested&lt;User&gt;(n =&gt; n
                .Name(nn =&gt; nn.User)
            )
        )
    )
);

var indexResponse = client.Index(new GroupDoc
{
    Group = "fans",
    User = new List&lt;User&gt;
                    {
                        new User { First = "John", Last = "Smith" },
                        new User { First = "Alice", Last = "White" }
                    }
}, i =&gt; i
    .Index("my_index")
    .Id(1)
);

var searchResponse = client.Search&lt;GroupDoc&gt;(s =&gt; s
    .Index("my_index")
    .Query(q =&gt; q
        .Nested(n =&gt; n
            .Path(p =&gt; p.User)
            .Query(nq =&gt; nq
                .Match(m =&gt; m
                    .Field(f =&gt; f.User[0].First)
                    .Query("Alice")
                ) &amp;&amp; nq
                .Match(m =&gt; m
                    .Field(f =&gt; f.User[0].Last)
                    .Query("Smith")
                )
            )
        )
    )
);

var searchResponse2 = client.Search&lt;GroupDoc&gt;(s =&gt; s
    .Index("my_index")
    .Query(q =&gt; q
        .Nested(n =&gt; n
            .Path(p =&gt; p.User)
            .Query(nq =&gt; nq
                .Match(m =&gt; m
                    .Field(f =&gt; f.User[0].First)
                    .Query("Alice")
                ) &amp;&amp; nq
                .Match(m =&gt; m
                    .Field(f =&gt; f.User[0].Last)
                    .Query("White")
                )
            )
            .InnerHits(i =&gt; i
                .Highlight(h =&gt; h
                    .Fields(hf =&gt; hf
                        .Field(f =&gt; f.User[0].First)
                    )
                )
            )
        )
    )
);</pre>
</div>
<div class="pre_wrapper lang-python alternative">
<pre class="programlisting prettyprint lang-python alternative">resp = client.indices.create(
    index="my_index",
    body={"mappings": {"properties": {"user": {"type": "nested"}}}},
)
print(resp)

resp = client.index(
    index="my_index",
    id="1",
    body={
        "group": "fans",
        "user": [
            {"first": "John", "last": "Smith"},
            {"first": "Alice", "last": "White"},
        ],
    },
)
print(resp)

resp = client.search(
    index="my_index",
    body={
        "query": {
            "nested": {
                "path": "user",
                "query": {
                    "bool": {
                        "must": [
                            {"match": {"user.first": "Alice"}},
                            {"match": {"user.last": "Smith"}},
                        ]
                    }
                },
            }
        }
    },
)
print(resp)

resp = client.search(
    index="my_index",
    body={
        "query": {
            "nested": {
                "path": "user",
                "query": {
                    "bool": {
                        "must": [
                            {"match": {"user.first": "Alice"}},
                            {"match": {"user.last": "White"}},
                        ]
                    }
                },
                "inner_hits": {
                    "highlight": {"fields": {"user.first": {}}}
                },
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.indices.create(
  index: 'my_index',
  body: {
    mappings: {
      properties: {
        user: {
          type: 'nested'
        }
      }
    }
  }
)
puts response

response = client.indices.create(
  index: 'my_index',
  id: 1,
  body: {
    group: 'fans',
    user: [
      {
        first: 'John',
        last: 'Smith'
      },
      {
        first: 'Alice',
        last: 'White'
      }
    ]
  }
)
puts response

response = client.indices.create(
  index: 'my_index',
  body: {
    query: {
      nested: {
        path: 'user',
        query: {
          bool: {
            must: [
              {
                match: {
                  "user.first": 'Alice'
                }
              },
              {
                match: {
                  "user.last": 'Smith'
                }
              }
            ]
          }
        }
      }
    }
  }
)
puts response

response = client.indices.create(
  index: 'my_index',
  body: {
    query: {
      nested: {
        path: 'user',
        query: {
          bool: {
            must: [
              {
                match: {
                  "user.first": 'Alice'
                }
              },
              {
                match: {
                  "user.last": 'White'
                }
              }
            ]
          }
        },
        inner_hits: {
          highlight: {
            fields: {
              "user.first": {
              }
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<pre class="programlisting prettyprint lang-go alternative">{
	res, err := es.Indices.Create(
		"my_index",
		es.Indices.Create.WithBody(strings.NewReader(`{
	  "mappings": {
	    "properties": {
	      "user": {
	        "type": "nested"
	      }
	    }
	  }
	}`)),
	)
	fmt.Println(res, err)
}

{
	res, err := es.Index(
		"my_index",
		strings.NewReader(`{
	  "group": "fans",
	  "user": [
	    {
	      "first": "John",
	      "last": "Smith"
	    },
	    {
	      "first": "Alice",
	      "last": "White"
	    }
	  ]
	}`),
		es.Index.WithDocumentID("1"),
		es.Index.WithPretty(),
	)
	fmt.Println(res, err)
}

{
	res, err := es.Search(
		es.Search.WithIndex("my_index"),
		es.Search.WithBody(strings.NewReader(`{
	  "query": {
	    "nested": {
	      "path": "user",
	      "query": {
	        "bool": {
	          "must": [
	            {
	              "match": {
	                "user.first": "Alice"
	              }
	            },
	            {
	              "match": {
	                "user.last": "Smith"
	              }
	            }
	          ]
	        }
	      }
	    }
	  }
	}`)),
		es.Search.WithPretty(),
	)
	fmt.Println(res, err)
}

{
	res, err := es.Search(
		es.Search.WithIndex("my_index"),
		es.Search.WithBody(strings.NewReader(`{
	  "query": {
	    "nested": {
	      "path": "user",
	      "query": {
	        "bool": {
	          "must": [
	            {
	              "match": {
	                "user.first": "Alice"
	              }
	            },
	            {
	              "match": {
	                "user.last": "White"
	              }
	            }
	          ]
	        }
	      },
	      "inner_hits": {
	        "highlight": {
	          "fields": {
	            "user.first": {}
	          }
	        }
	      }
	    }
	  }
	}`)),
		es.Search.WithPretty(),
	)
	fmt.Println(res, err)
}</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<pre class="programlisting prettyprint lang-js alternative">const response0 = await client.indices.create({
  index: 'my_index',
  body: {
    mappings: {
      properties: {
        user: {
          type: 'nested'
        }
      }
    }
  }
})
console.log(response0)

const response1 = await client.index({
  index: 'my_index',
  id: '1',
  body: {
    group: 'fans',
    user: [
      {
        first: 'John',
        last: 'Smith'
      },
      {
        first: 'Alice',
        last: 'White'
      }
    ]
  }
})
console.log(response1)

const response2 = await client.search({
  index: 'my_index',
  body: {
    query: {
      nested: {
        path: 'user',
        query: {
          bool: {
            must: [
              {
                match: {
                  'user.first': 'Alice'
                }
              },
              {
                match: {
                  'user.last': 'Smith'
                }
              }
            ]
          }
        }
      }
    }
  }
})
console.log(response2)

const response3 = await client.search({
  index: 'my_index',
  body: {
    query: {
      nested: {
        path: 'user',
        query: {
          bool: {
            must: [
              {
                match: {
                  'user.first': 'Alice'
                }
              },
              {
                match: {
                  'user.last': 'White'
                }
              }
            ]
          }
        },
        inner_hits: {
          highlight: {
            fields: {
              'user.first': {}
            }
          }
        }
      }
    }
  }
})
console.log(response3)</pre>
</div>
<a id="b919f88e6f47a40d5793479440a90ba6"></a>
<div class="pre_wrapper lang-console default has-csharp has-python has-ruby has-go has-js">
<pre class="programlisting prettyprint lang-console default has-csharp has-python has-ruby has-go has-js">PUT my_index
{
  "mappings": {
    "properties": {
      "user": {
        "type": "nested" <a id="CO306-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}

PUT my_index/_doc/1
{
  "group" : "fans",
  "user" : [
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}

GET my_index/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            { "match": { "user.first": "Alice" }},
            { "match": { "user.last":  "Smith" }} <a id="CO306-2"></a><i class="conum" data-value="2"></i>
          ]
        }
      }
    }
  }
}

GET my_index/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            { "match": { "user.first": "Alice" }},
            { "match": { "user.last":  "White" }} <a id="CO306-3"></a><i class="conum" data-value="3"></i>
          ]
        }
      },
      "inner_hits": { <a id="CO306-4"></a><i class="conum" data-value="4"></i>
        "highlight": {
          "fields": {
            "user.first": {}
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-csharp has-python has-ruby has-go has-js" data-snippet="snippets/655.console"></div>
<div class="calloutlist default has-csharp has-python has-ruby has-go has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO306-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">user</code> field is mapped as type <code class="literal">nested</code> instead of type <code class="literal">object</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO306-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>This query doesn&#8217;t match because <code class="literal">Alice</code> and <code class="literal">Smith</code> are not in the same nested object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO306-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>This query matches because <code class="literal">Alice</code> and <code class="literal">White</code> are in the same nested object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO306-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">inner_hits</code> allow us to highlight the matching nested documents.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="nested-accessing-documents"></a>Interacting with <code class="literal">nested</code> documents<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/mapping/types/nested.asciidoc">edit</a></h3>
</div></div></div>
<p>Nested documents can be:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
queried with the <a class="xref" href="query-dsl-nested-query.html" title="Nested query"><code class="literal">nested</code></a> query.
</li>
<li class="listitem">
analyzed with the <a class="xref" href="search-aggregations-bucket-nested-aggregation.html" title="Nested Aggregation"><code class="literal">nested</code></a>
and <a class="xref" href="search-aggregations-bucket-reverse-nested-aggregation.html" title="Reverse nested Aggregation"><code class="literal">reverse_nested</code></a>
aggregations.
</li>
<li class="listitem">
sorted with <a class="xref" href="search-request-body.html#nested-sorting" title="Sorting within nested objects.">nested sorting</a>.
</li>
<li class="listitem">
retrieved and highlighted with <a class="xref" href="search-request-body.html#nested-inner-hits" title="Nested inner hits">nested inner hits</a>.
</li>
</ul>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>Because nested documents are indexed as separate documents, they can only be
accessed  within the scope of the <code class="literal">nested</code> query, the
<code class="literal">nested</code>/<code class="literal">reverse_nested</code> aggregations, or <a class="xref" href="search-request-body.html#nested-inner-hits" title="Nested inner hits">nested inner hits</a>.</p>
<p>For instance, if a string field within a nested document has
<a class="xref" href="index-options.html" title="index_options"><code class="literal">index_options</code></a> set to <code class="literal">offsets</code> to allow use of the postings
during the highlighting, these offsets will not be available during the main highlighting
phase.  Instead, highlighting needs to be performed via
<a class="xref" href="search-request-body.html#nested-inner-hits" title="Nested inner hits">nested inner hits</a>. The same consideration applies when loading
fields during a search through <a class="xref" href="search-request-body.html#request-body-search-docvalue-fields" title="Doc value Fields"><code class="literal">docvalue_fields</code></a>
or <a class="xref" href="search-request-body.html#request-body-search-stored-fields" title="Stored Fields"><code class="literal">stored_fields</code></a>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="nested-params"></a>Parameters for <code class="literal">nested</code> fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/mapping/types/nested.asciidoc">edit</a></h3>
</div></div></div>
<p>The following parameters are accepted by <code class="literal">nested</code> fields:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<a class="xref" href="dynamic.html" title="dynamic"><code class="literal">dynamic</code></a>
</span>
</dt>
<dd>
(Optional, string)
Whether or not new <code class="literal">properties</code> should be added dynamically to an existing
nested object.  Accepts <code class="literal">true</code> (default), <code class="literal">false</code> and <code class="literal">strict</code>.
</dd>
<dt>
<span class="term">
<a class="xref" href="properties.html" title="properties"><code class="literal">properties</code></a>
</span>
</dt>
<dd>
(Optional, object)
The fields within the nested object, which can be of any
<a class="xref" href="mapping-types.html" title="Field datatypes">datatype</a>, including <code class="literal">nested</code>. New properties
may be added to an existing nested object.
</dd>
<dt>
<span class="term">
<code class="literal">include_in_parent</code>
</span>
</dt>
<dd>
(Optional, boolean)
If <code class="literal">true</code>, all fields in the nested object are also added to the parent document
as standard (flat) fields. Defaults to <code class="literal">false</code>.
</dd>
<dt>
<span class="term">
<code class="literal">include_in_root</code>
</span>
</dt>
<dd>
(Optional, boolean)
If <code class="literal">true</code>, all fields in the nested object are also added to the root
document as standard (flat) fields. Defaults to <code class="literal">false</code>.
</dd>
</dl>
</div>
<h3><a id="_limits_on_nested_mappings_and_objects"></a>Limits on <code class="literal">nested</code> mappings and objects<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/mapping/types/nested.asciidoc">edit</a></h3>
<p>As described earlier, each nested object is indexed as a separate Lucene document.
Continuing with the previous example, if we indexed a single document containing 100 <code class="literal">user</code> objects,
then 101 Lucene documents would be created: one for the parent document, and one for each
nested object. Because of the expense associated with <code class="literal">nested</code> mappings, Elasticsearch puts
settings in place to guard against performance problems:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">index.mapping.nested_fields.limit</code>
</span>
</dt>
<dd>
The maximum number of distinct <code class="literal">nested</code> mappings in an index. The <code class="literal">nested</code> type should only be used in special cases, when arrays of objects need to be queried independently of each other. To safeguard against poorly designed mappings, this setting
limits the number of unique <code class="literal">nested</code> types per index. Default is <code class="literal">50</code>.
</dd>
</dl>
</div>
<p>In the previous example, the <code class="literal">user</code> mapping would count as only 1 towards this limit.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">index.mapping.nested_objects.limit</code>
</span>
</dt>
<dd>
The maximum number of nested JSON objects that a single document can contain across all
<code class="literal">nested</code> types. This limit helps to prevent out of memory errors when a document contains too many nested
objects. Default is <code class="literal">10000</code>.
</dd>
</dl>
</div>
<p>To illustrate how this setting works, consider adding another <code class="literal">nested</code> type called <code class="literal">comments</code>
to the previous example mapping. For each document, the combined number of <code class="literal">user</code> and <code class="literal">comment</code>
objects it contains must be below the limit.</p>
<p>See <a class="xref" href="mapping.html#mapping-limit-settings" title="Settings to prevent mappings explosion">Settings to prevent mappings explosion</a> regarding additional settings for preventing mappings explosion.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="keyword.html">« Keyword datatype</a>
</span>
<span class="next">
<a href="number.html">Numeric datatypes »</a>
</span>
</div>
</div>
</body>
</html>
